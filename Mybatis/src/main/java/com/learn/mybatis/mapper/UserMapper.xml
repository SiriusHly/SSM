<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
<!--namespace:接口类-->
<mapper namespace="com.learn.mybatis.dao.UserDao">
    <!--id代表它的标识，type代表使用哪个类作为其映射的类，可以是别名或者全限定名-->
    <resultMap id="userMap" type="user">
        <!--id代表主键，property代表pojo的名称，column代表SQL字段名-->
        <id property="userRegisterId" column="user_register_id"/>
        <result property="userPassword" column="user_password"/>
        <result property="userNickName" column="user_nickname"/>
    </resultMap>
    <!--Sql语句段-->
    <sql id="selectUser">
        user_register_id as userRegisterId ,user_nickname as userNickName
    </sql>

    <!--resultMap制定采用哪个resultMap-->
    <select id="getUserResultMap" parameterType="string" resultMap="userMap" >
        SELECT user_register_id,user_password,user_nickname FROM [user] WHERE user_register_id = #{userRegisterId}
    </select>
    <!--parameterType:标出是什么类型的参数，SQL接受的参数类型-->
    <!--id要和接口定义的方法名称相同-->
    <insert id="insertUser" parameterType="user">
        <!--<selectKey keyProperty="user_id" resultType="int" order="BEFORE">
            select if (max(user_id) = null,1,max(user_id)+3) FROM [user]
        </selectKey>-->
        INSERT INTO [user](user_register_id,user_password,user_nickname)VALUES(#{userRegisterId,jdbcType=VARCHAR},#{userPassword,jdbcType=VARCHAR},#{userNickName,jdbcType=VARCHAR})
    </insert>

    <!--resultType结果映射成什么样的类型-->
    <select id="getUser" parameterType="string" resultType="user">
        <!--每一个字段都要分别as-->
        <!--数据库列名和pojo列名不相同时用此种方法，-->
        SELECT <include refid="selectUser"/> from [user] WHERE user_register_id = #{userRegisterId}
    </select>

    <!--mybatis模糊查询-->
    <select id="findUser" parameterType="string" resultType="user">
        SELECT user_register_id as userResisterId,user_password as userPassword, user_nickname as userNickName from [user] WHERE user_nickname like concat('%',#{userNickName},'%')
    </select>

    <select id="userCount" resultType="int">
        SELECT COUNT(*) FROM [user]
    </select>

    <!--map接口多参数查询-->
    <select id="findUserIdAndNick" parameterType="map" resultType="user">
        SELECT user_register_id as userRegisterId ,user_password as userPassword FROM [user] WHERE user_register_id = #{userRegisterId} AND user_nickname like CONCAT('%', #{userNickName},'%')
    </select>

    <!--@Param多参数查询,不需要parameterType，@Param参数名字代替Pojo名字-->
    <select id="findUserBaseIdANDNick"  resultType="user">
        SELECT user_register_id as userRegisterId ,user_password as userPassword FROM [user] WHERE user_register_id = #{userRegisterId} AND user_nickname like CONCAT('%', #{userNick},'%')
    </select>

    <!--Java bean多参数查询-->
    <select id="findUserByBean"  resultType="user">
        SELECT user_register_id as userRegisterId ,user_password as userPassword FROM [user] WHERE user_register_id = #{userRegisterId} AND user_nickname like CONCAT('%', #{userNickName},'%')
    </select>

    <!--混合查询-->
    <!--Top后面是不允许使用问号占位符的，‘@P0’附近有语法错误就是由此引起的。-->
    <!--将Top后面的占位符改为${}的方式，相当于字符串拼接-->
    <select id="findByMix"  resultType="user">
        SELECT TOP ${page.start} user_register_id as userRegisterId ,user_password as userPassword FROM [user] WHERE user_register_id = #{params.userRegisterId} AND user_nickname like CONCAT('%', #{params.userNickName},'%') AND
        user_register_id NOT IN(SELECT TOP ${page.limit} user_register_id FROM [user])
    </select>

    <!--RowBounds分页-->
    <select id="findByRowBounds" resultType="user">
        <!--只有传入的参数才用别名，不然结果为null-->
        SELECT user_nickname as userNickName FROM [user] WHERE  user_nickname LIKE CONCAT('%', #{uNick}, '%')
    </select>

    <!--更新角色-->
    <update id="updateUser" parameterType="user">
        UPDATE [user] SET user_nickname = #{userNickName} WHERE user_register_id =#{userRegisterId}
    </update>

    <!--删除角色-->
    <delete id="deleteUser" parameterType="string">
        DELETE from [user] WHERE user_register_id = #{userRegisterId}
    </delete>


</mapper>